<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analyzing | HenryHQ</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=DM+Sans:opsz,wght@9..40,400;9..40,500;9..40,600&display=swap" rel="stylesheet">
    <style>
        :root {
            --color-bg: #0a0a0b;
            --color-text: #fafafa;
            --color-text-secondary: #a1a1aa;
            --font-display: 'Instrument Serif', Georgia, serif;
            --font-body: 'DM Sans', -apple-system, sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            background: var(--color-bg);
            color: var(--color-text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            -webkit-font-smoothing: antialiased;
        }

        .logo-container {
            margin-bottom: 48px;
        }

        .logo-svg {
            width: 160px;
            height: 160px;
        }

        /* Dot animation - bounces in and out of circle */
        @keyframes dotBounce {
            0%, 100% {
                transform: translate(0, 0);
            }
            25% {
                transform: translate(12px, -12px);
            }
            50% {
                transform: translate(0, 0);
            }
            75% {
                transform: translate(-8px, 8px);
            }
        }

        .peak-dot {
            animation: dotBounce 2.5s ease-in-out infinite;
            transform-origin: center;
        }

        /* Subtle pulse on the ring */
        @keyframes ringPulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
        }

        .ring-circle {
            animation: ringPulse 3s ease-in-out infinite;
        }

        .status-container {
            text-align: center;
        }

        .status-text {
            font-size: 1.1rem;
            color: var(--color-text);
            margin-bottom: 12px;
            min-height: 28px;
        }

        .status-subtext {
            font-size: 0.9rem;
            color: var(--color-text-secondary);
        }

        /* Progress dots */
        .progress-dots {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-top: 32px;
        }

        .progress-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        .progress-dot.active {
            background: #764ba2;
        }

        .progress-dot.completed {
            background: #667eea;
        }

        /* Error state */
        .error-message {
            display: none;
            text-align: center;
            margin-top: 24px;
        }

        .error-message.show {
            display: block;
        }

        .error-message p {
            color: #f87171;
            margin-bottom: 16px;
        }

        .error-message button {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--color-text);
            padding: 10px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-family: var(--font-body);
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .error-message button:hover {
            border-color: rgba(255, 255, 255, 0.4);
            background: rgba(255, 255, 255, 0.05);
        }
    </style>
    <link rel="stylesheet" href="css/mobile.css">
</head>
<body>
    <div class="logo-container">
        <svg class="logo-svg" viewBox="0 0 200 200" fill="none" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <linearGradient id="ringGradient" x1="0%" y1="100%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color:#667eea;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" />
                </linearGradient>

                <linearGradient id="strokeGradient" x1="0%" y1="100%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color:#667eea;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" />
                </linearGradient>
            </defs>

            <!-- Thin ring -->
            <circle class="ring-circle" cx="100" cy="100" r="85"
                    stroke="url(#ringGradient)"
                    stroke-width="4"
                    fill="none"/>

            <!-- Left vertical (grounded) -->
            <path d="M55 130 L55 70"
                  stroke="#667eea"
                  stroke-width="9"
                  stroke-linecap="round"
                  fill="none"/>

            <!-- Right vertical (ascending) -->
            <path d="M145 130 L145 50"
                  stroke="url(#strokeGradient)"
                  stroke-width="9"
                  stroke-linecap="round"
                  fill="none"/>

            <!-- Horizontal connector -->
            <path d="M55 100 L145 100"
                  stroke="#764ba2"
                  stroke-width="9"
                  stroke-linecap="round"
                  fill="none"/>

            <!-- Peak dot (animated) -->
            <circle class="peak-dot" cx="145" cy="50" r="9" fill="#764ba2"/>
        </svg>
    </div>

    <div class="status-container">
        <div class="status-text" id="statusText">Reading job description...</div>
        <div class="status-subtext" id="statusSubtext">This usually takes 30-45 seconds</div>

        <div class="progress-dots">
            <div class="progress-dot active" id="dot1"></div>
            <div class="progress-dot" id="dot2"></div>
            <div class="progress-dot" id="dot3"></div>
            <div class="progress-dot" id="dot4"></div>
        </div>
    </div>

    <div class="error-message" id="errorMessage">
        <p id="errorText">Something went wrong. Please try again.</p>
        <button onclick="goBack()">Go Back</button>
    </div>

    <script>
        const API_BASE_URL = window.location.hostname === 'localhost'
            ? 'http://localhost:8000'
            : 'https://henryai-app-production.up.railway.app';

        const statusText = document.getElementById('statusText');
        const statusSubtext = document.getElementById('statusSubtext');
        const errorMessage = document.getElementById('errorMessage');
        const errorText = document.getElementById('errorText');

        let currentDot = 1;

        function updateStage(dot, text, subtext) {
            statusText.textContent = text;
            statusSubtext.textContent = subtext;

            for (let i = 1; i <= 4; i++) {
                const dotEl = document.getElementById(`dot${i}`);
                dotEl.classList.remove('active', 'completed');
                if (i < dot) {
                    dotEl.classList.add('completed');
                } else if (i === dot) {
                    dotEl.classList.add('active');
                }
            }
            currentDot = dot;
        }

        function showError(message) {
            errorText.textContent = message;
            errorMessage.classList.add('show');
            statusText.textContent = 'Analysis failed';
            statusSubtext.textContent = '';
        }

        function goBack() {
            window.location.href = '/analyze';
        }

        async function runAnalysis() {
            // Get the pending analysis data from sessionStorage
            const pendingData = sessionStorage.getItem('pendingAnalysis');
            if (!pendingData) {
                showError('No analysis data found. Please try again.');
                return;
            }

            const { requestPayload, resumeJson, candidateName, company, role, jobDescription } = JSON.parse(pendingData);

            // Start with initial stage
            updateStage(1, 'Reading job description...', 'This usually takes 15-30 seconds');

            // Fallback timer: if no streaming events arrive, advance stages on a timer
            const fallbackTimers = [
                setTimeout(() => { if (currentDot < 2) updateStage(2, 'Analyzing your fit...', 'Comparing your experience to requirements'); }, 8000),
                setTimeout(() => { if (currentDot < 3) updateStage(3, 'Building your strategy...', 'Crafting positioning recommendations'); }, 18000),
                setTimeout(() => { if (currentDot < 4) updateStage(4, 'Finalizing analysis...', 'Almost there'); }, 30000),
            ];

            try {
                console.log('Sending streaming analysis request to:', `${API_BASE_URL}/api/jd/analyze/stream`);

                // Extract only the fields the streaming API expects (exclude 'profile')
                const { company: reqCompany, role_title, job_description, resume, preferences } = requestPayload;
                const streamPayload = { company: reqCompany, role_title, job_description, resume, preferences };

                const response = await fetch(`${API_BASE_URL}/api/jd/analyze/stream`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(streamPayload)
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.detail || `Analysis failed (${response.status})`);
                }

                // Read the SSE stream
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop(); // Keep incomplete line in buffer

                    for (const line of lines) {
                        if (!line.startsWith('data: ')) continue;

                        let data;
                        try {
                            data = JSON.parse(line.slice(6));
                        } catch (e) {
                            console.error('Failed to parse SSE event:', e, line);
                            continue;
                        }

                        const { type, field, value: eventValue, message } = data;

                        if (type === 'start') {
                            console.log('Stream started:', message);
                        }
                        else if (type === 'partial') {
                            if (field === 'fit_score') {
                                updateStage(2, 'Analyzing your fit...', `Fit score: ${eventValue}%`);
                                console.log('ðŸŽ¯ Streaming fit_score:', eventValue);
                            }
                            else if (field === 'recommendation') {
                                updateStage(3, 'Building your strategy...', `Recommendation: ${eventValue}`);
                                console.log('ðŸ“‹ Streaming recommendation:', eventValue);
                            }
                            else if (field === 'strengths') {
                                updateStage(3, 'Building your strategy...', `Found ${eventValue.length} key strengths`);
                                console.log('ðŸ’ª Streaming strengths:', eventValue);
                            }
                            else if (field === 'expected_applicants') {
                                updateStage(4, 'Finalizing analysis...', 'Almost there');
                                console.log('ðŸ“Š Streaming expected_applicants:', eventValue);
                            }
                        }
                        else if (type === 'complete') {
                            // Clear fallback timers
                            fallbackTimers.forEach(t => clearTimeout(t));

                            updateStage(4, 'Analysis complete', 'Redirecting to results...');

                            const analysisData = data.data;
                            console.log('âœ… Stream complete, building full data');
                            console.log('ðŸ” fit_score:', analysisData.fit_score);
                            console.log('ðŸ” recommendation:', analysisData.recommendation);

                            // Build full data for results page (same enrichment as non-streaming path)
                            const userProfile = JSON.parse(localStorage.getItem('userProfile') || '{}');
                            const extractedCompany = analysisData.company || company;
                            const extractedRole = analysisData.role_title || role;
                            const applicationId = `app_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

                            const fullData = {
                                ...analysisData,
                                _resume_json: resumeJson,
                                _candidate_name: candidateName,
                                _company: extractedCompany,
                                _company_name: extractedCompany,
                                _role: extractedRole,
                                _jd_text: jobDescription,
                                _profile: userProfile,
                                _applicationId: applicationId,
                                _createdAt: new Date().toISOString()
                            };

                            // Store analysis data (with localStorage backup for Safari)
                            const analysisDataStr = JSON.stringify(fullData);
                            sessionStorage.setItem('analysisData', analysisDataStr);
                            localStorage.setItem('analysisData_backup', analysisDataStr);

                            // Clear pending data
                            sessionStorage.removeItem('pendingAnalysis');

                            // Redirect to results page
                            window.location.href = '/results';
                            return;
                        }
                        else if (type === 'error') {
                            throw new Error(message || 'Analysis stream error');
                        }
                    }
                }

                // If stream ended without a complete event
                if (!sessionStorage.getItem('analysisData')) {
                    throw new Error('Analysis incomplete. Please try again.');
                }

            } catch (error) {
                console.error('Analysis error:', error);
                fallbackTimers.forEach(t => clearTimeout(t));

                let errorMsg = 'Something went wrong. Please try again.';
                if (error.name === 'TypeError' && error.message === 'Failed to fetch') {
                    errorMsg = 'Unable to connect to the server. Please check your connection and try again.';
                } else if (error.message && error.message.includes('temporarily busy')) {
                    errorMsg = error.message;
                } else if (error.message && error.message.includes('Claude API')) {
                    errorMsg = 'Our AI is temporarily unavailable. Please try again in a moment.';
                } else if (error.message) {
                    errorMsg = error.message;
                }

                showError(errorMsg);
            }
        }

        // Start analysis when page loads
        runAnalysis();
    </script>
    <script src="components/analytics.js"></script>
<script src="components/status-banner.js"></script>
</body>
</html>
