<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generating Documents | HenryHQ</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=DM+Sans:opsz,wght@9..40,400;9..40,500;9..40,600&display=swap" rel="stylesheet">
    <style>
        :root {
            --color-bg: #0a0a0b;
            --color-text: #fafafa;
            --color-text-secondary: #a1a1aa;
            --font-display: 'Instrument Serif', Georgia, serif;
            --font-body: 'DM Sans', -apple-system, sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            background: var(--color-bg);
            color: var(--color-text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            -webkit-font-smoothing: antialiased;
        }

        .logo-container {
            margin-bottom: 48px;
        }

        .logo-svg {
            width: 160px;
            height: 160px;
        }

        /* Dot animation - bounces in and out of circle */
        @keyframes dotBounce {
            0%, 100% {
                transform: translate(0, 0);
            }
            25% {
                transform: translate(12px, -12px);
            }
            50% {
                transform: translate(0, 0);
            }
            75% {
                transform: translate(-8px, 8px);
            }
        }

        .peak-dot {
            animation: dotBounce 2.5s ease-in-out infinite;
            transform-origin: center;
        }

        /* Subtle pulse on the ring */
        @keyframes ringPulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
        }

        .ring-circle {
            animation: ringPulse 3s ease-in-out infinite;
        }

        .status-container {
            text-align: center;
        }

        .status-text {
            font-size: 1.1rem;
            color: var(--color-text);
            margin-bottom: 12px;
            min-height: 28px;
        }

        .status-subtext {
            font-size: 0.9rem;
            color: var(--color-text-secondary);
        }

        /* Progress dots */
        .progress-dots {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-top: 32px;
        }

        .progress-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        .progress-dot.active {
            background: #764ba2;
        }

        .progress-dot.completed {
            background: #667eea;
        }

        /* Error state */
        .error-message {
            display: none;
            text-align: center;
            margin-top: 24px;
        }

        .error-message.show {
            display: block;
        }

        .error-message p {
            color: #f87171;
            margin-bottom: 16px;
        }

        .error-message button {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--color-text);
            padding: 10px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-family: var(--font-body);
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .error-message button:hover {
            border-color: rgba(255, 255, 255, 0.4);
            background: rgba(255, 255, 255, 0.05);
        }
    </style>
    <link rel="stylesheet" href="css/mobile.css">
    <!-- Supabase Auth -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="js/supabase-client.js"></script>
</head>
<body>
    <div class="logo-container">
        <svg class="logo-svg" viewBox="0 0 200 200" fill="none" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <linearGradient id="ringGradient" x1="0%" y1="100%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color:#667eea;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" />
                </linearGradient>

                <linearGradient id="strokeGradient" x1="0%" y1="100%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color:#667eea;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" />
                </linearGradient>
            </defs>

            <!-- Thin ring -->
            <circle class="ring-circle" cx="100" cy="100" r="85"
                    stroke="url(#ringGradient)"
                    stroke-width="4"
                    fill="none"/>

            <!-- Left vertical (grounded) -->
            <path d="M55 130 L55 70"
                  stroke="#667eea"
                  stroke-width="9"
                  stroke-linecap="round"
                  fill="none"/>

            <!-- Right vertical (ascending) -->
            <path d="M145 130 L145 50"
                  stroke="url(#strokeGradient)"
                  stroke-width="9"
                  stroke-linecap="round"
                  fill="none"/>

            <!-- Horizontal connector -->
            <path d="M55 100 L145 100"
                  stroke="#764ba2"
                  stroke-width="9"
                  stroke-linecap="round"
                  fill="none"/>

            <!-- Peak dot (animated) -->
            <circle class="peak-dot" cx="145" cy="50" r="9" fill="#764ba2"/>
        </svg>
    </div>

    <div class="status-container">
        <div class="status-text" id="statusText">Crafting your resume...</div>
        <div class="status-subtext" id="statusSubtext">This usually takes 30-60 seconds</div>

        <div class="progress-dots">
            <div class="progress-dot active" id="dot1"></div>
            <div class="progress-dot" id="dot2"></div>
            <div class="progress-dot" id="dot3"></div>
            <div class="progress-dot" id="dot4"></div>
        </div>
    </div>

    <div class="error-message" id="errorMessage">
        <p id="errorText">Something went wrong. Please try again.</p>
        <div style="display: flex; gap: 12px; justify-content: center;">
            <button onclick="retryGeneration()">Try Again</button>
            <button onclick="goBack()" style="background: transparent; border: 1px solid rgba(255, 255, 255, 0.2);">Go Back</button>
        </div>
    </div>

    <script>
        const API_BASE_URL = window.location.hostname === 'localhost'
            ? 'http://localhost:8000'
            : 'https://henryai-app-production.up.railway.app';

        const statusText = document.getElementById('statusText');
        const statusSubtext = document.getElementById('statusSubtext');
        const errorMessage = document.getElementById('errorMessage');
        const errorText = document.getElementById('errorText');

        // Browser detection for timeout handling
        function isFirefox() {
            return navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
        }

        function isSafari() {
            return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        }

        // Get appropriate timeout based on browser (Firefox needs longer)
        function getTimeoutDuration() {
            if (isFirefox()) {
                return 180000; // 3 minutes for Firefox
            }
            return 120000; // 2 minutes for Chrome/Safari/others
        }

        const stages = [
            { text: 'Crafting your resume...', subtext: 'Tailoring content to the role', dot: 1 },
            { text: 'Writing your cover letter...', subtext: 'Highlighting your strengths', dot: 2 },
            { text: 'Preparing interview talking points...', subtext: 'Building your story', dot: 3 },
            { text: 'Finalizing your package...', subtext: 'Almost there', dot: 4 }
        ];

        let currentStage = 0;

        function updateStage(stageIndex) {
            if (stageIndex >= stages.length) return;

            const stage = stages[stageIndex];
            statusText.textContent = stage.text;
            statusSubtext.textContent = stage.subtext;

            // Update dots
            for (let i = 1; i <= 4; i++) {
                const dot = document.getElementById(`dot${i}`);
                dot.classList.remove('active', 'completed');
                if (i < stage.dot) {
                    dot.classList.add('completed');
                } else if (i === stage.dot) {
                    dot.classList.add('active');
                }
            }
        }

        function showError(message) {
            // Add browser-specific guidance
            let enhancedMessage = message;
            if (isFirefox() && (message.includes('Connection lost') || message.includes('taking longer') || message.includes('AbortError'))) {
                enhancedMessage = `${message}\n\nFirefox users: This may be a browser timeout issue. Try using Chrome or Safari, or wait a few minutes and try again.`;
            }

            errorText.textContent = enhancedMessage;
            errorMessage.classList.add('show');
            statusText.textContent = 'Generation failed';
            statusSubtext.textContent = '';
        }

        function goBack() {
            // Go back to resume-leveling (user may have skipped strengthen)
            window.location.href = '/resume-leveling';
        }

        function retryGeneration() {
            // Hide error, reset progress, and try again
            errorMessage.classList.remove('show');
            statusText.textContent = 'Crafting your resume...';
            statusSubtext.textContent = 'This usually takes 30-60 seconds';
            // Reset dots
            for (let i = 1; i <= 4; i++) {
                const dot = document.getElementById(`dot${i}`);
                dot.classList.remove('active', 'completed');
            }
            document.getElementById('dot1').classList.add('active');
            // Retry
            generateDocuments();
        }

        // Progress through stages while waiting
        function startProgressAnimation() {
            // Stage 2 after 8 seconds
            setTimeout(() => updateStage(1), 8000);
            // Stage 3 after 20 seconds
            setTimeout(() => updateStage(2), 20000);
            // Stage 4 after 40 seconds
            setTimeout(() => updateStage(3), 40000);
        }

        async function generateDocuments() {
            // Get analysis data with localStorage fallback (Safari compatibility)
            let analysisDataStr = sessionStorage.getItem('analysisData');

            // Safari fallback: check localStorage if sessionStorage is empty
            if (!analysisDataStr) {
                analysisDataStr = localStorage.getItem('analysisData_backup');
                if (analysisDataStr) {
                    console.log('Safari fallback: loaded analysisData from localStorage');
                    sessionStorage.setItem('analysisData', analysisDataStr);
                }
            }

            if (!analysisDataStr) {
                showError('No analysis data found. Please go back to the results page and try again.');
                console.error('Missing analysisData in sessionStorage');
                return;
            }

            let analysisData;
            try {
                analysisData = JSON.parse(analysisDataStr);
            } catch (e) {
                showError('Invalid analysis data. Please go back to the results page and try again.');
                console.error('Failed to parse analysisData:', e);
                return;
            }

            // Validate critical fields
            if (!analysisData._resume_json) {
                showError('Resume data is missing. Please go back to your profile and re-upload your resume.');
                console.error('Missing _resume_json in analysisData:', Object.keys(analysisData));
                return;
            }

            // Generate unique application ID if not already present (prevents duplicates on retry)
            if (!analysisData._applicationId) {
                analysisData._applicationId = `app_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                sessionStorage.setItem('analysisData', JSON.stringify(analysisData));
            }

            console.log('Starting document generation with analysisData:', {
                hasResumeJson: !!analysisData._resume_json,
                resumeType: typeof analysisData._resume_json,
                company: analysisData._company || analysisData._company_name,
                role: analysisData._role || analysisData.role_title,
                applicationId: analysisData._applicationId
            });

            // Get supplements from sessionStorage
            const supplementsStr = sessionStorage.getItem('supplements');
            const supplements = supplementsStr ? JSON.parse(supplementsStr) : [];

            // Get leveling data from sessionStorage (from resume-leveling page)
            const levelingDataStr = sessionStorage.getItem('levelingData');
            const levelingData = levelingDataStr ? JSON.parse(levelingDataStr) : null;

            startProgressAnimation();

            // Create AbortController for timeout handling
            // Firefox needs longer timeout due to stricter connection handling
            const controller = new AbortController();
            const timeoutDuration = getTimeoutDuration();
            console.log(`ðŸ• Using ${timeoutDuration/1000}s timeout (Firefox: ${isFirefox()})`);
            const timeoutId = setTimeout(() => controller.abort(), timeoutDuration);

            try {
                // Parse resume JSON if it's a string (handle double-encoding)
                let resumeJson = analysisData._resume_json || {};
                let parseAttempts = 0;
                while (typeof resumeJson === 'string' && parseAttempts < 3) {
                    try {
                        resumeJson = JSON.parse(resumeJson);
                        parseAttempts++;
                        console.log(`Parsed resume JSON (attempt ${parseAttempts})`);
                    } catch (e) {
                        console.error('Failed to parse resume_json string:', e);
                        resumeJson = {};
                        break;
                    }
                }

                // Build request payload for document generation
                const requestPayload = {
                    resume: resumeJson,
                    jd_analysis: {
                        role_title: analysisData.role_title || analysisData._role || '',
                        company_name: analysisData._company_name || analysisData._company || '',
                        job_description: analysisData._jd_text || '',
                        fit_score: analysisData.fit_score || 50,
                        strengths: analysisData.strengths || [],
                        gaps: analysisData.gaps || [],
                        intelligence_layer: analysisData.intelligence_layer || {}
                    },
                    preferences: analysisData._profile || {},
                    supplements: supplements.length > 0 ? supplements : undefined,
                    // Include leveling data for level-appropriate document generation
                    // Only include if all required fields are present
                    leveling: (levelingData &&
                               levelingData.current_level &&
                               levelingData.current_level_id &&
                               levelingData.detected_function &&
                               levelingData.language_level) ? {
                        current_level: levelingData.current_level,
                        current_level_id: levelingData.current_level_id,
                        target_level: levelingData.target_level || null,
                        target_level_id: levelingData.target_level_id || null,
                        levels_apart: levelingData.levels_apart ?? null,
                        detected_function: levelingData.detected_function,
                        language_level: levelingData.language_level,
                        recommendations: levelingData.recommendations || [],
                        gaps: levelingData.gaps || []
                    } : undefined
                };

                console.log('Generating documents with payload:', requestPayload);
                console.log('Resume type:', typeof requestPayload.resume);
                console.log('Resume keys:', requestPayload.resume ? Object.keys(requestPayload.resume) : 'none');
                console.log('Leveling data present:', !!requestPayload.leveling);

                const response = await fetch(`${API_BASE_URL}/api/documents/generate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestPayload),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                if (!response.ok) {
                    let errorDetail = `Document generation failed (${response.status})`;
                    let isValidationError = false;
                    try {
                        const errorData = await response.json();
                        console.error('API Error Response (raw):', JSON.stringify(errorData, null, 2));

                        // Check if this is our custom validation error (QA blocked)
                        if (errorData && errorData.detail && typeof errorData.detail === 'object') {
                            const detail = errorData.detail;
                            if (detail.error === 'validation_failed' && detail.user_message) {
                                // Use the user-friendly message from the backend
                                errorDetail = detail.user_message;
                                isValidationError = true;
                                console.log('QA Validation blocked output:', detail.validation);
                            } else if (detail.message) {
                                errorDetail = detail.message;
                            } else if (Array.isArray(detail)) {
                                // Pydantic validation errors come as array with loc, msg, type fields
                                const messages = detail.map(e => {
                                    if (!e || typeof e !== 'object') return String(e);
                                    const loc = Array.isArray(e.loc) ? e.loc.join('.') : '';
                                    const msg = String(e.msg || e.message || '');
                                    return loc ? `${loc}: ${msg}` : msg || JSON.stringify(e);
                                });
                                errorDetail = messages.join('; ') || 'Validation error';
                            } else {
                                errorDetail = JSON.stringify(detail);
                            }
                        } else if (errorData && errorData.detail) {
                            if (typeof errorData.detail === 'string') {
                                errorDetail = errorData.detail;
                            } else {
                                errorDetail = JSON.stringify(errorData.detail);
                            }
                        } else if (errorData && errorData.message) {
                            errorDetail = String(errorData.message);
                        } else if (errorData) {
                            errorDetail = JSON.stringify(errorData);
                        }
                    } catch (parseErr) {
                        console.error('Could not parse error response:', parseErr);
                    }
                    console.error('Final error detail:', errorDetail);

                    // For validation errors, show with retry option
                    if (isValidationError) {
                        showError(errorDetail + ' Click "Go Back" to check your resume data, or try generating again.');
                        return;
                    }
                    throw new Error(errorDetail);
                }

                const documentsData = await response.json();
                console.log('Documents generated:', documentsData);

                // Store documents data in sessionStorage
                sessionStorage.setItem('documentsData', JSON.stringify(documentsData));

                // Also persist to localStorage for later access
                const companyName = analysisData._company_name || analysisData._company || 'Unknown';
                const roleTitle = analysisData.role_title || analysisData._role || 'Unknown';
                const documentsKey = `documents_${companyName}_${roleTitle}`.toLowerCase().replace(/[^a-z0-9_]/g, '_');
                localStorage.setItem(documentsKey, JSON.stringify({
                    ...documentsData,
                    _company: companyName,
                    _role: roleTitle,
                    _generatedAt: new Date().toISOString()
                }));

                // Sync documents to Supabase (update the application record)
                if (typeof HenryData !== 'undefined') {
                    try {
                        const session = await HenryAuth.getSession();
                        if (session) {
                            // Find the application for this company/role and update with documents
                            const apps = await HenryData.getApplications();
                            const matchingApp = apps.find(app =>
                                app.company.toLowerCase() === companyName.toLowerCase() &&
                                app.role.toLowerCase() === roleTitle.toLowerCase()
                            );
                            if (matchingApp) {
                                matchingApp.documentsData = documentsData;
                                const result = await HenryData.saveApplication(matchingApp);
                                if (result.error) {
                                    console.error('Error saving documents to Supabase:', result.error);
                                } else {
                                    console.log('Documents synced to Supabase');
                                }
                            }
                        }
                    } catch (err) {
                        console.error('Supabase documents sync error:', err);
                    }
                }

                // Clear supplements and leveling data after use
                sessionStorage.removeItem('supplements');
                sessionStorage.removeItem('originalGaps');
                sessionStorage.removeItem('levelingData');

                // Go to Application Strategy Overview
                window.location.href = '/overview';

            } catch (error) {
                clearTimeout(timeoutId);
                console.error('Error generating documents:', error);

                // Re-throw with enhanced error message for retry wrapper to handle
                let errorMsg = 'Something went wrong. Please try again.';
                if (error.name === 'AbortError') {
                    errorMsg = 'Generation is taking longer than expected. Our AI might be busy. Please try again in a few minutes.';
                } else if (error.name === 'TypeError' && error.message === 'Failed to fetch') {
                    errorMsg = 'Unable to connect to the server. Please check your connection and try again.';
                } else if (error.message && error.message.includes('NetworkError')) {
                    errorMsg = 'Connection lost during generation. Please check your internet and try again.';
                } else if (typeof error === 'string') {
                    errorMsg = error;
                } else if (error && typeof error.message === 'string') {
                    errorMsg = error.message;
                } else if (error && typeof error.detail === 'string') {
                    errorMsg = error.detail;
                }

                // Re-throw with enhanced message so retry wrapper can handle it
                const enhancedError = new Error(errorMsg);
                enhancedError.name = error.name || 'GenerationError';
                throw enhancedError;
            }
        }

        // Retry wrapper with exponential backoff
        async function generateDocumentsWithRetry(maxRetries = 2) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    console.log(`ðŸ”„ Generation attempt ${attempt}/${maxRetries}`);
                    await generateDocuments();
                    return; // Success, exit
                } catch (error) {
                    console.error(`âŒ Attempt ${attempt} failed:`, error);

                    // Only retry on network/timeout errors, not validation errors
                    const isRetryable = error.name === 'AbortError' ||
                        (error.message && (error.message.includes('NetworkError') ||
                         error.message.includes('Failed to fetch') ||
                         error.message.includes('Connection lost')));

                    if (attempt < maxRetries && isRetryable) {
                        const waitTime = attempt * 5000; // 5s, then 10s
                        console.log(`â³ Waiting ${waitTime/1000}s before retry...`);

                        // Update UI to show retry status
                        statusText.textContent = `Retrying... (attempt ${attempt + 1})`;
                        statusSubtext.textContent = `Please wait ${waitTime/1000} seconds`;

                        await new Promise(resolve => setTimeout(resolve, waitTime));

                        // Reset progress dots
                        for (let i = 1; i <= 4; i++) {
                            const dot = document.getElementById(`dot${i}`);
                            dot.classList.remove('active', 'completed');
                        }
                        document.getElementById('dot1').classList.add('active');
                    } else {
                        // Final attempt failed or non-retryable error
                        let finalMsg = 'Generation failed after multiple attempts. Our AI might be overloaded. Please try again in a few minutes.';
                        if (!isRetryable) {
                            finalMsg = error.message || 'Generation failed. Please try again.';
                        }
                        if (isFirefox()) {
                            finalMsg += ' Firefox users may have better success with Chrome or Safari.';
                        }
                        showError(finalMsg);
                        return;
                    }
                }
            }
        }

        // Start generation when page loads (with retry support)
        generateDocumentsWithRetry();
    </script>
<script src="components/analytics.js"></script>
</body>
</html>
